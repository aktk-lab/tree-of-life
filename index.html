<!doctype html>
<html lang="ja"><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>🌳 生命の樹 — Root Dominion v2</title>
<style>
:root{ --cell:84px }
*{box-sizing:border-box}
body{margin:0;background:radial-gradient(800px 500px at 50% -10%,rgba(52,211,153,.10),transparent 60%),linear-gradient(180deg,#081b16,#0e1f28);color:#e9fff6;font:16px/1.6 system-ui,"Noto Sans JP",sans-serif}
h1{font-size:18px;margin:10px 6px;text-align:center;text-shadow:0 0 14px rgba(16,185,129,.35)}
.header{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;align-items:center;padding:8px}
.pill{border:1px solid #1f473f;border-radius:999px;padding:4px 10px;background:#0b2823;font-size:12px}
.btn{padding:9px 12px;border-radius:10px;border:1px solid #1f473f;background:#11443b;color:#e9fff6;cursor:pointer}
.btn:active{transform:translateY(1px)}
input[type=range]{width:150px}
.wrap{max-width:620px;margin:0 auto;padding:10px}
.board{display:grid;grid-template-columns:repeat(5,1fr);gap:8px}
.cell{width:var(--cell);height:var(--cell);border:1px solid #1f473f;border-radius:12px;background:linear-gradient(180deg,#0f3a32,#0b2b25);display:flex;align-items:center;justify-content:center;font-size:26px;position:relative}
.src{position:absolute;left:6px;top:6px;font-size:16px}
.you{box-shadow:inset 0 0 0 3px rgba(74,222,128,.6)}
.ai{box-shadow:inset 0 0 0 3px rgba(192,132,252,.6)}
.hl{outline:2px solid #60a5fa}
.small{font-size:12px;color:#bbf7d0;max-height:160px;overflow:auto;text-align:left}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:84px;background:#0b2823;border:1px solid #1f473f;color:#e5e7eb;padding:8px 12px;border-radius:10px;opacity:0;transition:opacity .2s, transform .35s;z-index:10}
.toast.show{opacity:1;transform:translateX(-50%) translateY(-8px)}
</style>
</head>
<body>
<h1>🌳 生命の樹 — Root Dominion v2</h1>
<div class="header">
  <span class="pill">🧙 あなた点:<b id="pS">0</b></span>
  <span class="pill">🤖 AI点:<b id="aS">0</b></span>
  <span class="pill">🔋 EP:<b id="ep">2</b></span>
  <button id="end" class="btn">⏭️ ターン終了</button>
  <button id="new" class="btn">🔁 リセット</button>
  <button id="unlock" class="btn">🔓 強制解除</button>
  <button id="z-" class="btn">−</button><input id="z" type="range" min="70" max="110" value="84"><button id="z+" class="btn">＋</button>
</div>

<div class="wrap">
  <div id="board" class="board"></div>
  <div id="log" class="small"></div>
</div>
<div id="toast" class="toast">text</div>

<script>
(function(){
  "use strict";
  const N=5;
  const SRC_TYPES=['💧','🌞','⛰','🍄','🔥',null]; // null=空地
  const COST_BASE=2;
  const el=id=>document.getElementById(id);
  const tip=t=>{const x=el('toast'); x.textContent=t; x.classList.add('show'); setTimeout(()=>x.classList.remove('show'),900);};
  const log=m=>{const L=el('log'); L.innerHTML+=m+'<br>'; L.scrollTop=L.scrollHeight;};
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  let S;

  function reset(){
    // 盤生成：中央列は少し資源濃い
    const grid=[...Array(N)].map(()=>[...Array(N)].map(()=>({owner:0,src:pick()})));
    grid[2][0].src=null; grid[2][N-1].src=null; // 幹位置は空
    S={
      grid, turn:'you', ep:COST_BASE, p:{score:0, trunk:[2,0]}, a:{score:0, trunk:[2,N-1]},
      busy:false
    };
    // 幹を設置
    cell(2,0).owner=1; cell(2,N-1).owner=2;
    renderAll();
    el('log').innerHTML=''; log('▶️ 開始：あなたの番');
  }
  function pick(){
    // 少し資源寄り
    const r=Math.random();
    if(r<0.18) return '💧';
    if(r<0.33) return '🌞';
    if(r<0.46) return '⛰';
    if(r<0.59) return '🍄';
    if(r<0.69) return '🔥';
    return null;
  }
  const cell=(r,c)=>S.grid[r][c];

  function neighbors([r,c]){
    return [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([y,x])=>y>=0&&y<N&&x>=0&&x<N);
  }
  function renderAll(){
    el('pS').textContent=S.p.score; el('aS').textContent=S.a.score; el('ep').textContent=S.ep;
    const B=el('board'); B.innerHTML='';
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const d=document.createElement('div'); d.className='cell';
        const cc=cell(r,c);
        if(cc.owner===1) d.classList.add('you'); else if(cc.owner===2) d.classList.add('ai');
        d.dataset.r=r; d.dataset.c=c;
        d.innerHTML=`<div class="src">${cc.src?cc.src:''}</div>${cc.owner===1?'🟢':cc.owner===2?'🟣':''}`;
        B.appendChild(d);
      }
    }
    highlight();
  }
  function highlight(){
    document.querySelectorAll('.hl').forEach(n=>n.classList.remove('hl'));
    if(S.turn!=='you') return;
    const frontier = frontierCells(1);
    frontier.forEach(([r,c])=>{
      const d=document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      if(d) d.classList.add('hl');
    });
  }
  function frontierCells(owner){
    // 自分の根に隣接する空きマス
    const f=[];
    for(let r=0;r<N;r++)for(let c=0;c<N;c++){
      if(cell(r,c).owner===owner){
        for(const nb of neighbors([r,c])){
          const t=cell(...nb);
          if(t.owner===0 && !includesCoord(f, nb)) f.push(nb);
        }
      }
    }
    return f;
  }
  function includesCoord(list,[r,c]){ return list.some(([y,x])=>y===r&&x===c); }

  function grow(owner, to){
    // コスト計算
    let cost=COST_BASE;
    const s = cell(...to).src;
    if(s==='🌞') cost=Math.max(1,cost-1);
    if(s==='💧') S.ep+=1;        // 即時ボーナス
    if(s==='🔥') { if(owner===1) S.p.score=Math.max(0,S.p.score-1); else S.a.score=Math.max(0,S.a.score-1); } // 罰
    if(S.ep<cost){ tip('EP不足'); return false; }
    S.ep-=cost;
    cell(...to).owner = owner;
    if(s==='⛰'){ /*防御：今回は見た目のみ*/ }
    // 連結3で果実⭐
    const gained = checkFruit(owner);
    if(gained>0){
      if(owner===1) S.p.score+=3; else S.a.score+=3;
      log(`${owner===1?'あなた':'AI'} ⭐ 果実 +3`);
    }
    // 菌糸：連結ボーナス
    if(s==='🍄'){
      const len = longestChain(owner);
      if(owner===1) S.p.score += 1; else S.a.score += 1;
      log(`${owner===1?'あなた':'AI'} 🍄 連結ボーナス +1（連結長=${len}）`);
    }
    return true;
  }

  function checkFruit(owner){
    // 直線3連結が生まれたか
    let made=0;
    // 横
    for(let r=0;r<N;r++){
      for(let c=0;c<=N-3;c++){
        if(cell(r,c).owner===owner && cell(r,c+1).owner===owner && cell(r,c+2).owner===owner){
          made++;
        }
      }
    }
    // 縦
    for(let c=0;c<N;c++){
      for(let r=0;r<=N-3;r++){
        if(cell(r,r?c:c).owner===owner && cell(r+1,c).owner===owner && cell(r+2,c).owner===owner){
          made++;
        }
      }
    }
    return made;
  }

  function longestChain(owner){
    // BFSで最大連結長
    const seen=[...Array(N)].map(()=>Array(N).fill(false));
    let best=0;
    for(let r=0;r<N;r++)for(let c=0;c<N;c++){
      if(cell(r,c).owner!==owner || seen[r][c]) continue;
      let q=[[r,c]]; seen[r][c]=true; let cnt=0;
      while(q.length){ const [y,x]=q.shift(); cnt++;
        for(const nb of neighbors([y,x])){
          if(!seen[nb[0]][nb[1]] && cell(...nb).owner===owner){ seen[nb[0]][nb[1]]=true; q.push(nb); }
        }
      }
      best=Math.max(best,cnt);
    }
    return best;
  }

  function endTurn(){
    if(S.busy) return; S.busy=true;
    try{
      // 収穫：連結長を得点化（小さめ）
      const add = Math.max(0, longestChain(1)-1);
      if(add>0){ S.p.score+=add; log(`🌾 収穫：+${add}`); }
      // 勝利判定
      if(S.p.score>=20 || S.a.score>=20) return finish();
      // AIへ
      S.turn='ai'; S.ep=COST_BASE;
      renderAll();
      setTimeout(aiStep, 300);
    } finally { /* busyはAI側でクリア */ }
  }

  function finish(){
    const res = S.p.score>=20 && S.p.score>=S.a.score ? '勝利！' : '敗北…';
    alert(`対戦終了：${res}\nあなた ${S.p.score} / AI ${S.a.score}`);
    S.busy=false;
  }

  function aiStep(){
    // EPを使い切るまで成長（最大3回）
    let steps=0;
    while(S.turn==='ai' && S.ep>0 && steps<6){
      const cand = frontierCells(2);
      if(cand.length===0) break;
      // 評価：資源価値 + 自連結期待 − 相手妨害価値の一部
      let best=null;
      for(const pos of cand){
        const score = evalMove(2,pos);
        if(!best || score>best.sc) best={pos,sc:score};
      }
      if(!grow(2,best.pos)) break;
      steps++;
    }
    // 収穫
    const add = Math.max(0, longestChain(2)-1);
    if(add>0){ S.a.score+=add; log(`🤖🌾 収穫：+${add}`); }
    if(S.p.score>=20 || S.a.score>=20){ S.busy=false; return finish(); }
    // プレイヤーへ
    S.turn='you'; S.ep=COST_BASE; S.busy=false; renderAll(); log('🪵 あなたの番');
  }

  function evalMove(owner,pos){
    const s = cell(...pos).src;
    const resVal = (s==='💧'?1.2 : s==='🌞'?0.8 : s==='⛰'?0.6 : s==='🍄'?1.4 : s==='🔥'?-1.2 : 0.5);
    // 長く繋がりそうな方向を好む（近傍に自根が多いほど+）
    let near=0;
    for(const nb of neighbors(pos)){ if(cell(...nb).owner===owner) near++; }
    // 相手の前進ラインを塞ぐ（相手が隣接しているなら+）
    let block=0;
    for(const nb of neighbors(pos)){ if(cell(...nb).owner=== (owner===1?2:1)) block+=0.6; }
    return resVal + near*0.8 + block*0.6;
  }

  // ===== UI =====
  el('board').addEventListener('click',(e)=>{
    if(S.busy || S.turn!=='you') return;
    const d=e.target.closest('.cell'); if(!d) return;
    const r=+d.dataset.r, c=+d.dataset.c;
    // 自根に隣接＆空きか？
    const fr=frontierCells(1).some(([y,x])=>y===r&&x===c);
    if(!fr){ tip('そこには伸ばせません'); return; }
    if(grow(1,[r,c])){ renderAll(); }
  });
  el('end').onclick=()=>endTurn();
  el('new').onclick=()=>reset();
  el('unlock').onclick=()=>{ S.busy=false; tip('🔓解除'); };

  // ズーム
  const zr=el('z');
  const apply=(v)=>{
    const x=clamp(+v,70,110); zr.value=x; document.documentElement.style.setProperty('--cell',x+'px'); renderAll();
  };
  el('z-').onclick=()=>apply(zr.value-6);
  el('z+').onclick=()=>apply(+zr.value+6);
  zr.oninput=()=>apply(zr.value);

  window.onload=()=>{ apply(zr.value); reset(); };
})();
</script>
</body>
</html>
